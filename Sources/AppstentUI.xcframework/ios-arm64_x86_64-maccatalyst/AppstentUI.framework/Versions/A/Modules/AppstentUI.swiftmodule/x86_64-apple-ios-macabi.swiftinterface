// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.6.1 (swiftlang-5.6.0.323.66 clang-1316.0.20.12)
// swift-module-flags: -target x86_64-apple-ios15.0-macabi -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name AppstentUI
@_exported import AppstentUI
import Combine
import CoreData
import Foundation
import Swift
import SwiftUI
import _AVKit_SwiftUI
import _Concurrency
public struct AppstentDoc : Swift.Identifiable, Swift.Hashable {
  public let id: Foundation.UUID
  public var name: Swift.String
  public var lastModified: Foundation.Date?
  public var content: Swift.String
  public var isFolder: Swift.Bool
  public var children: [AppstentUI.AppstentDoc]?
  public init(name: Swift.String, lastModified: Foundation.Date? = nil, isFolder: Swift.Bool = false)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: AppstentUI.AppstentDoc, b: AppstentUI.AppstentDoc) -> Swift.Bool
  public typealias ID = Foundation.UUID
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class ContentFormatUtil {
  public static func color(from colorString: Swift.String) -> SwiftUI.Color?
  public static func alignment(from alignmentString: Swift.String) -> SwiftUI.Alignment?
  public static func unitPoint(from unitPointString: Swift.String) -> SwiftUI.UnitPoint?
  @objc deinit
}
@_Concurrency.MainActor public struct ContentView : SwiftUI.View {
  @_Concurrency.MainActor public var customDataProvider: AppstentUI.CustomContentDataProvider?
  @_Concurrency.MainActor public static var customViewProvider: AppstentUI.CustomContentViewProvider?
  @_Concurrency.MainActor(unsafe) public var body: some SwiftUI.View {
    get
  }
  @_Concurrency.MainActor public init(from viewContent: AppstentUI.ViewContent, dataProvider: AppstentUI.CustomContentDataProvider? = nil)
  public typealias Body = @_opaqueReturnTypeOf("$s10AppstentUI11ContentViewV4bodyQrvp", 0) __
}
public struct ContentViewStyle : SwiftUI.ViewModifier {
  @_Concurrency.MainActor(unsafe) public func body(content: AppstentUI.ContentViewStyle.Content) -> some SwiftUI.View
  
  public init(from viewContent: AppstentUI.ViewContent)
  public typealias Body = @_opaqueReturnTypeOf("$s10AppstentUI16ContentViewStyleV4body7contentQr05SwiftB001_d9Modifier_C0VyACG_tF", 0) __
}
extension SwiftUI.View {
  @inlinable public func shadow(from viewContent: AppstentUI.ViewContent) -> some SwiftUI.View {
        
        guard let shadow:ViewContent = viewContent.shadow else {
            return AnyView(self)
        }
        
        let colorString:String = shadow.color
        
        if let radius:Float = shadow.radius,
           !colorString.isEmpty {
                        
            let color = ContentFormatUtil.color(from: colorString) ?? .black
            
            return AnyView(self.shadow(color: color, radius: CGFloat(radius), x: 0.0, y: 0.0))
        }
        
        return AnyView(self)
    }
  
  @inlinable public func blur(from viewContent: AppstentUI.ViewContent) -> some SwiftUI.View {
        
        guard let blur:ViewContent = viewContent.blur else {
            return AnyView(self)
        }
        
        if let radius:Float = blur.radius {
            
            let opaque:Bool = blur.opaque
            
            return AnyView(self.blur(radius: CGFloat(radius), opaque: opaque))
        }
        
        return AnyView(self)
    }
  
  @inlinable public func backgroundColor(from viewContent: AppstentUI.ViewContent) -> some SwiftUI.View {
        
        let colorString:String = viewContent.backgroundColor
        
        if !colorString.isEmpty {
            
            if let color = ContentFormatUtil.color(from: colorString) {
                return AnyView(self.background(color))
            }
        }
        
        return AnyView(self)
    }
  
  @inlinable public func foregroundColor(from viewContent: AppstentUI.ViewContent) -> some SwiftUI.View {
        
        let colorString:String = viewContent.foregroundColor
        
        if !colorString.isEmpty {
            
            if let color = ContentFormatUtil.color(from: colorString) {
                return AnyView(self.foregroundColor(color))
            }
        }
        
        return AnyView(self)
    }
  
  @inlinable public func font(from viewContent: AppstentUI.ViewContent) -> some SwiftUI.View {
        
        var font: Font?
        let fontString:String = viewContent.font

        switch fontString {
        case "largeTitle":  font = Font.largeTitle
        case "title":       font = Font.title
        case "title2":      font = Font.title2
        case "title3":      font = Font.title3
        case "headline":    font = Font.headline
        case "subheadline": font = Font.subheadline
        case "body":        font = Font.body
        case "callout":     font = Font.callout
        case "footnote":    font = Font.footnote
        case "caption":     font = Font.caption
        case "caption2":    font = Font.caption2
        default:
            if let fontSize:Float = viewContent.fontSize {
                font = .custom(fontString, size: CGFloat(fontSize))
            }
        }
        
        if var font = font {
            
            let fontWeight:String = viewContent.fontWeight
            
            switch fontWeight {
            case "ultraLight":  font = font.weight(.ultraLight)
            case "thin":        font = font.weight(.thin)
            case "light":       font = font.weight(.light)
            case "regular":     font = font.weight(.regular)
            case "medium":      font = font.weight(.medium)
            case "semibold":    font = font.weight(.semibold)
            case "bold":        font = font.weight(.bold)
            case "heavy":       font = font.weight(.heavy)
            case "black":       font = font.weight(.black)
            default: break
            }
            
            return AnyView(self.font(font))
        }
        
        return AnyView(self)
    }
  
  @inlinable public func padding(from viewContent: AppstentUI.ViewContent) -> some SwiftUI.View {
        
        if let paddingValue:Float = viewContent.padding {
            
            if paddingValue == 0 {
                return AnyView(self.padding())
            } else {
                return AnyView(self.padding(CGFloat(paddingValue)))
            }
        }
        
        return AnyView(self)
    }
  
  @inlinable public func offset(from viewContent: AppstentUI.ViewContent) -> some SwiftUI.View {
        
        let offsetX:Float = viewContent.offsetX ?? 0
        let offsetY:Float = viewContent.offsetY ?? 0
        
        return AnyView(self.offset(x: CGFloat(offsetX), y: CGFloat(offsetY)))
    }
  
  @inlinable public func position(from viewContent: AppstentUI.ViewContent) -> some SwiftUI.View {
        
        let positionX:Float = viewContent.positionX ?? 0
        let positionY:Float = viewContent.positionY ?? 0
        
        return AnyView(self.offset(x: CGFloat(positionX), y: CGFloat(positionY)))
    }
  
  @inlinable public func border(from viewContent: AppstentUI.ViewContent) -> some SwiftUI.View {
        
        let borderWidth:Float = (viewContent.borderWidth) ?? 1
        let colorString:String = viewContent.borderColor
        
        if !colorString.isEmpty,
           let color = ContentFormatUtil.color(from: colorString) {
            
            return AnyView(self.border(color, width: CGFloat(borderWidth)))
        }

        return AnyView(self)
    }
  
  @inlinable public func fixedSize(from viewContent: AppstentUI.ViewContent) -> some SwiftUI.View {
        
        let fixedWidth:Bool = viewContent.fixedWidth
        let fixedHeight:Bool = viewContent.fixedHeight
        
                
        return AnyView(fixedSize(horizontal: fixedWidth, vertical: fixedHeight))
    }
  
  @inlinable public func frame(from viewContent: AppstentUI.ViewContent) -> some SwiftUI.View {
        
        let width:Float? = viewContent.width
        let height:Float? = viewContent.height
        
        let idealWidth:Float? = viewContent.idealWidth
        let idealHeight:Float? = viewContent.idealHeight
        
        let minWidth:Float? = viewContent.minWidth
        let maxWidth:Float? = viewContent.maxWidth
        let minHeight:Float? = viewContent.minHeight
        let maxHeight:Float? = viewContent.maxHeight
        
        let alignmentValue:String = viewContent.alignment
        let alignment:Alignment = ContentFormatUtil.alignment(from: alignmentValue) ?? .center
                
        return AnyView(self.frame(minWidth: minWidth != nil ? CGFloat(minWidth!) : nil,
                                  idealWidth: idealWidth != nil ? CGFloat(idealWidth!) : nil,
                                  maxWidth: maxWidth != nil ? CGFloat(maxWidth!) : nil,
                                  minHeight: minHeight != nil ? CGFloat(minHeight!) : nil,
                                  idealHeight: idealHeight != nil ? CGFloat(idealHeight!) : nil,
                                  maxHeight: maxHeight != nil ? CGFloat(maxHeight!) : nil,
                                  alignment: alignment)
                        .frame(width: width != nil ? CGFloat(width!) : nil,
                               height: height != nil ? CGFloat(height!) : nil,
                               alignment: alignment))
    }
  
  @inlinable public func cornerRadius(from viewContent: AppstentUI.ViewContent) -> some SwiftUI.View {
        
        guard let radius:Float = viewContent.cornerRadius else {
            return AnyView(self)
        }
        
        return AnyView(self.cornerRadius(CGFloat(radius)))
    }
  
  @inlinable public func clip(from viewContent: AppstentUI.ViewContent) -> some SwiftUI.View {
        
        let shapeName:String = viewContent.clipShape
        
        guard !shapeName.isEmpty else {
            return AnyView(self)
        }
        
        switch shapeName {
        case "circle":
            return AnyView(self.clipShape(Circle()))
        default:
            return AnyView(self)
        }
    }
  
}
extension SwiftUI.View {
  @inlinable public func listStyle(from viewContent: AppstentUI.ViewContent) -> some SwiftUI.View {
           
        let fontString:String = viewContent.listStyle
        
        switch fontString {
        case "plainListStyle":  return AnyView(self.listStyle(PlainListStyle()))
        case "sidebarListStyle":  return AnyView(self.listStyle(SidebarListStyle()))
        case "insetListStyle":  return AnyView(self.listStyle(InsetListStyle()))
        case "groupedListStyle":  return AnyView(self.listStyle(GroupedListStyle()))
        case "insetGroupedListStyle":  return AnyView(self.listStyle(InsetGroupedListStyle()))
            
        default:
            return AnyView(self.listStyle(DefaultListStyle()))
        }
    }
  
}
extension SwiftUI.View {
  @inlinable public func tabViewStyle(from tabStyleString: Swift.String) -> some SwiftUI.View {
                   
        switch tabStyleString {
        case "pageStyle":  return AnyView(self.tabViewStyle(.page))
            
        default:
            return AnyView(self.tabViewStyle(DefaultTabViewStyle()))
        }
    }
  
}
public protocol CustomContentDataProvider {
  func string(for fieldName: Swift.String) -> Swift.String
}
@dynamicCallable @dynamicMemberLookup public class ViewContent : Swift.Hashable, Foundation.ObservableObject {
  public static func == (lhs: AppstentUI.ViewContent, rhs: AppstentUI.ViewContent) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @Combine.Published @_projectedValueProperty($isLoaded) public var isLoaded: Swift.Bool {
    get
    set
    _modify
  }
  public var $isLoaded: Combine.Published<Swift.Bool>.Publisher {
    get
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    set
  }
  public static var deploymentStage: Swift.String
  public static var apiKey: Swift.String
  public init(from dict: Swift.AnyObject)
  @_Concurrency.MainActor public init(from contentId: Swift.String)
  public init(from data: Foundation.Data)
  public subscript(dynamicMember member: Swift.String) -> Swift.String {
    get
  }
  public subscript(dynamicMember member: Swift.String) -> [AppstentUI.ViewContent] {
    get
  }
  public subscript(dynamicMember member: Swift.String) -> [Swift.String] {
    get
  }
  public subscript(dynamicMember member: Swift.String) -> AppstentUI.ViewContent? {
    get
  }
  public subscript(dynamicMember member: Swift.String) -> Swift.Float? {
    get
  }
  public subscript(dynamicMember member: Swift.String) -> Swift.Bool {
    get
  }
  public func dynamicallyCall(withKeywordArguments args: Swift.KeyValuePairs<Swift.String, Swift.AnyObject>)
  
  #if compiler(>=5.3) && $AsyncAwait
  @available(macOS 12, iOS 15, *)
  public static func update(content: Swift.String, with name: Swift.String, to subPath: Swift.String = "") async -> Swift.Bool
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait
  @available(macOS 12, iOS 15, *)
  public static func getContent(with name: Swift.String, under subPath: Swift.String = "") async -> Foundation.Data?
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait
  @available(macOS 12, iOS 15, *)
  public static func getAllViewContents(under subPath: Swift.String = "") async -> [AppstentUI.AppstentDoc]
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait
  @available(macOS 12, iOS 15, *)
  public static func deleteContent(with name: Swift.String, under subPath: Swift.String = "") async -> Swift.Bool
  #endif

  public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public protocol CustomContentViewProvider {
  func customView(from viewContent: AppstentUI.ViewContent) -> SwiftUI.AnyView
  func visibility(from visibilityRule: AppstentUI.ViewContent) -> Swift.Bool
}
extension AppstentUI.ContentView : Swift.Sendable {}
