// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.8 (swiftlang-5.8.0.124.2 clang-1403.0.22.11.100)
// swift-module-flags: -target x86_64-apple-macos12.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name AppstentUIMac
// swift-module-flags-ignorable: -enable-bare-slash-regex
import Combine
import CoreData
import Foundation
import Swift
import SwiftUI
import WebKit
import _AVKit_SwiftUI
import _Concurrency
import _StringProcessing
public struct AppstentDoc : Swift.Identifiable, Swift.Hashable {
  public let id: Foundation.UUID
  public var name: Swift.String
  public var lastModified: Foundation.Date?
  public var content: Swift.String
  public var isFolder: Swift.Bool
  public var children: [AppstentUIMac.AppstentDoc]?
  public init(name: Swift.String, lastModified: Foundation.Date? = nil, isFolder: Swift.Bool = false)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: AppstentUIMac.AppstentDoc, b: AppstentUIMac.AppstentDoc) -> Swift.Bool
  public typealias ID = Foundation.UUID
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class ContentFormatUtil {
  public static func color(from colorString: Swift.String) -> SwiftUI.Color?
  public static func alignment(from alignmentString: Swift.String) -> SwiftUI.Alignment?
  public static func verticalAlignment(from alignmentString: Swift.String) -> SwiftUI.VerticalAlignment
  public static func horizontalAlignment(from alignmentString: Swift.String) -> SwiftUI.HorizontalAlignment
  public static func unitPoint(from unitPointString: Swift.String) -> SwiftUI.UnitPoint?
  @objc deinit
}
@_Concurrency.MainActor public struct AppstentView : SwiftUI.View {
  @_Concurrency.MainActor public var customDataProvider: (any AppstentUIMac.CustomContentDataProvider)?
  @_Concurrency.MainActor public static var customViewProvider: (any AppstentUIMac.CustomContentViewProvider)?
  @_Concurrency.MainActor(unsafe) public var body: some SwiftUI.View {
    get
  }
  @_Concurrency.MainActor public init(from viewContent: AppstentUIMac.ViewContent, dataProvider: (any AppstentUIMac.CustomContentDataProvider)? = nil)
  public typealias Body = @_opaqueReturnTypeOf("$s13AppstentUIMac0A4ViewV4bodyQrvp", 0) __
}
public struct ContentViewStyle : SwiftUI.ViewModifier {
  @_Concurrency.MainActor(unsafe) public func body(content: AppstentUIMac.ContentViewStyle.Content) -> some SwiftUI.View
  
  public init(from viewContent: AppstentUIMac.ViewContent)
  public typealias Body = @_opaqueReturnTypeOf("$s13AppstentUIMac16ContentViewStyleV4body7contentQr7SwiftUI01_d9Modifier_C0VyACG_tF", 0) __
}
extension SwiftUI.View {
  @inlinable public func shadow(from viewContent: AppstentUIMac.ViewContent) -> some SwiftUI.View {
        
        guard let shadow:ViewContent = viewContent.shadow else {
            return AnyView(self)
        }
        
        let colorString:String = shadow.color
        let color = ContentFormatUtil.color(from: colorString) ?? .black
        
        if let radius:Float = shadow.radius {
                                    
            return AnyView(self.shadow(color: color, radius: CGFloat(radius), x: 0.0, y: 0.0))
        }
        
        return AnyView(self)
    }
  
  @inlinable public func blur(from viewContent: AppstentUIMac.ViewContent) -> some SwiftUI.View {
        
        guard let blur:ViewContent = viewContent.blur else {
            return AnyView(self)
        }
        
        if let radius:Float = blur.radius {
            
            let opaque:Bool = blur.opaque
            
            return AnyView(self.blur(radius: CGFloat(radius), opaque: opaque))
        }
        
        return AnyView(self)
    }
  
  @inlinable public func backgroundColor(from viewContent: AppstentUIMac.ViewContent) -> some SwiftUI.View {
        
        let colorString:String = viewContent.backgroundColor
        
        if !colorString.isEmpty {
            
            if let color = ContentFormatUtil.color(from: colorString) {
                return AnyView(self.background(color))
            }
        }
        
        return AnyView(self)
    }
  
  @inlinable public func foregroundColor(from viewContent: AppstentUIMac.ViewContent) -> some SwiftUI.View {
        
        let colorString:String = viewContent.foregroundColor
        
        if !colorString.isEmpty {
            
            if let color = ContentFormatUtil.color(from: colorString) {
                return AnyView(self.foregroundColor(color).tint(color))
            }
        }
        
        return AnyView(self)
    }
  
  @inlinable public func font(from viewContent: AppstentUIMac.ViewContent) -> some SwiftUI.View {
        
        var font: Font?
        let fontString:String = viewContent.font

        switch fontString {
        case "largeTitle":  font = Font.largeTitle
        case "title":       font = Font.title
        case "title2":      font = Font.title2
        case "title3":      font = Font.title3
        case "headline":    font = Font.headline
        case "subheadline": font = Font.subheadline
        case "body":        font = Font.body
        case "callout":     font = Font.callout
        case "footnote":    font = Font.footnote
        case "caption":     font = Font.caption
        case "caption2":    font = Font.caption2
        default:
            if let fontSize:Float = viewContent.fontSize {
                font = .custom(fontString, size: CGFloat(fontSize))
            }
        }
        
        if var font = font {
            
            let fontWeight:String = viewContent.fontWeight
            
            switch fontWeight {
            case "ultraLight":  font = font.weight(.ultraLight)
            case "thin":        font = font.weight(.thin)
            case "light":       font = font.weight(.light)
            case "regular":     font = font.weight(.regular)
            case "medium":      font = font.weight(.medium)
            case "semibold":    font = font.weight(.semibold)
            case "bold":        font = font.weight(.bold)
            case "heavy":       font = font.weight(.heavy)
            case "black":       font = font.weight(.black)
            default: break
            }
            
            return AnyView(self.font(font))
        }
        
        return AnyView(self)
    }
  
  @inlinable public func padding(from viewContent: AppstentUIMac.ViewContent) -> some SwiftUI.View {
        
        if let paddingValue:Float = viewContent.padding {
            
            if paddingValue == 0 {
                return AnyView(self.padding())
            } else {
                return AnyView(self.padding(CGFloat(paddingValue)))
            }
        }
        
        return AnyView(self)
    }
  
  @inlinable public func offset(from viewContent: AppstentUIMac.ViewContent) -> some SwiftUI.View {
        
        let offsetX:Float = viewContent.offsetX ?? 0
        let offsetY:Float = viewContent.offsetY ?? 0
        
        return AnyView(self.offset(x: CGFloat(offsetX), y: CGFloat(offsetY)))
    }
  
  @inlinable public func position(from viewContent: AppstentUIMac.ViewContent) -> some SwiftUI.View {
        
        let positionX:Float = viewContent.positionX ?? 0
        let positionY:Float = viewContent.positionY ?? 0
        
        return AnyView(self.offset(x: CGFloat(positionX), y: CGFloat(positionY)))
    }
  
  @inlinable public func border(from viewContent: AppstentUIMac.ViewContent) -> some SwiftUI.View {
        
        let borderWidth:Float = (viewContent.borderWidth) ?? 1
        let colorString:String = viewContent.borderColor
        
        if !colorString.isEmpty,
           let color = ContentFormatUtil.color(from: colorString) {
            
            return AnyView(self.border(color, width: CGFloat(borderWidth)))
        }

        return AnyView(self)
    }
  
  @inlinable public func fixedSize(from viewContent: AppstentUIMac.ViewContent) -> some SwiftUI.View {
        
        let fixedWidth:Bool = viewContent.fixedWidth
        let fixedHeight:Bool = viewContent.fixedHeight
        
                
        return AnyView(fixedSize(horizontal: fixedWidth, vertical: fixedHeight))
    }
  
  @inlinable public func frame(from viewContent: AppstentUIMac.ViewContent) -> some SwiftUI.View {
        
        let width:Float? = viewContent.width
        let height:Float? = viewContent.height
        
        let idealWidth:Float? = viewContent.idealWidth
        let idealHeight:Float? = viewContent.idealHeight
        
        let minWidth:Float? = viewContent.minWidth
        let maxWidth:Float? = viewContent.maxWidth
        let minHeight:Float? = viewContent.minHeight
        let maxHeight:Float? = viewContent.maxHeight
        
        let alignmentValue:String = viewContent.alignment
        let alignment:Alignment = ContentFormatUtil.alignment(from: alignmentValue) ?? .center
                
        return AnyView(self.frame(minWidth: minWidth != nil ? CGFloat(minWidth!) : nil,
                                  idealWidth: idealWidth != nil ? CGFloat(idealWidth!) : nil,
                                  maxWidth: maxWidth != nil ? CGFloat(maxWidth!) : nil,
                                  minHeight: minHeight != nil ? CGFloat(minHeight!) : nil,
                                  idealHeight: idealHeight != nil ? CGFloat(idealHeight!) : nil,
                                  maxHeight: maxHeight != nil ? CGFloat(maxHeight!) : nil,
                                  alignment: alignment)
                        .frame(width: width != nil ? CGFloat(width!) : nil,
                               height: height != nil ? CGFloat(height!) : nil,
                               alignment: alignment))
    }
  
  @inlinable public func cornerRadius(from viewContent: AppstentUIMac.ViewContent) -> some SwiftUI.View {
        
        guard let radius:Float = viewContent.cornerRadius else {
            return AnyView(self)
        }
        
        return AnyView(self.cornerRadius(CGFloat(radius)))
    }
  
  @inlinable public func clip(from viewContent: AppstentUIMac.ViewContent) -> some SwiftUI.View {
        
        let shapeName:String = viewContent.clipShape
        
        guard !shapeName.isEmpty else {
            return AnyView(self)
        }
        
        switch shapeName {
        case "circle":
            return AnyView(self.clipShape(Circle()))
        default:
            return AnyView(self)
        }
    }
  
}
extension SwiftUI.View {
  @inlinable public func listStyle(from viewContent: AppstentUIMac.ViewContent) -> some SwiftUI.View {
           
        let fontString:String = viewContent.listStyle
        
        switch fontString {
        case "plainListStyle":  return AnyView(self.listStyle(PlainListStyle()))
        case "sidebarListStyle":  return AnyView(self.listStyle(SidebarListStyle()))
        case "insetListStyle":  return AnyView(self.listStyle(InsetListStyle()))
            
        default:
            return AnyView(self.listStyle(DefaultListStyle()))
        }
    }
  
}
extension SwiftUI.Color {
  public static let backgroundColor: SwiftUI.Color
  public static let secondaryBackgroundColor: SwiftUI.Color
}
public struct CustomTabView : SwiftUI.View {
  public init(content: [(tabText: Swift.String, tabIcon: SwiftUI.AnyView, view: SwiftUI.AnyView)])
  public var tabBar: some SwiftUI.View {
    get
  }
  @_Concurrency.MainActor(unsafe) public var body: some SwiftUI.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s13AppstentUIMac13CustomTabViewV4bodyQrvp", 0) __
}
public protocol CustomContentDataProvider {
  func string(for fieldName: Swift.String) -> Swift.String
}
public enum LoadState {
  case notStarted, loading, success, failure
  public static func == (a: AppstentUIMac.LoadState, b: AppstentUIMac.LoadState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@dynamicCallable @dynamicMemberLookup public class ViewContent : Swift.Hashable, Foundation.ObservableObject {
  public static func == (lhs: AppstentUIMac.ViewContent, rhs: AppstentUIMac.ViewContent) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @Combine.Published @_projectedValueProperty($isLoaded) public var isLoaded: Swift.Bool {
    get
    set
    _modify
  }
  public var $isLoaded: Combine.Published<Swift.Bool>.Publisher {
    get
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    set
  }
  public static var deploymentStage: Swift.String
  public static var apiKey: Swift.String
  public init(from dict: Swift.AnyObject)
  @_Concurrency.MainActor public init(from contentId: Swift.String)
  public init(from data: Foundation.Data)
  public subscript(dynamicMember member: Swift.String) -> Swift.String {
    get
  }
  public subscript(dynamicMember member: Swift.String) -> [AppstentUIMac.ViewContent] {
    get
  }
  public subscript(dynamicMember member: Swift.String) -> [Swift.String] {
    get
  }
  public subscript(dynamicMember member: Swift.String) -> AppstentUIMac.ViewContent? {
    get
  }
  public subscript(dynamicMember member: Swift.String) -> Swift.Float? {
    get
  }
  public subscript(dynamicMember member: Swift.String) -> Swift.Bool {
    get
  }
  public func dynamicallyCall(withKeywordArguments args: Swift.KeyValuePairs<Swift.String, Swift.AnyObject>)
  #if compiler(>=5.3) && $AsyncAwait
  @available(macOS 12, iOS 15, *)
  public static func update(content: Swift.String, with name: Swift.String, to subPath: Swift.String = "") async -> Swift.Bool
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @available(macOS 12, iOS 15, *)
  public static func getContent(with name: Swift.String, under subPath: Swift.String = "") async -> Foundation.Data?
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @available(macOS 12, iOS 15, *)
  public static func getAllViewContents(under subPath: Swift.String = "") async -> [AppstentUIMac.AppstentDoc]
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @available(macOS 12, iOS 15, *)
  public static func deleteContent(with name: Swift.String, under subPath: Swift.String = "") async -> Swift.Bool
  #endif
  public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public protocol CustomContentViewProvider {
  func customView(from viewName: Swift.String) -> SwiftUI.AnyView
  func visibility(from ruleName: Swift.String, ruleValue: Swift.String) -> Swift.Bool
}
extension AppstentUIMac.AppstentView : Swift.Sendable {}
extension AppstentUIMac.LoadState : Swift.Equatable {}
extension AppstentUIMac.LoadState : Swift.Hashable {}
